"""
Problem 12 - Highly divisible triangular number
-------------------------------------------------------------------------------
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

"""
from functools import reduce

PRIME_FACTOR_MAX = 50
DESIRED_DIVISOR_COUNT = 500
prime_factors = [2]

# Find the first 10_000 primes
# Prep the Boolean list for Sieve of Eratosthenes
prime_num_booleans = [True for i in range(0,PRIME_FACTOR_MAX+1)]
for i in range(2, PRIME_FACTOR_MAX+1, 2):
    prime_num_booleans[i] = False

# Prime Number Sieve
for num in range(3, PRIME_FACTOR_MAX+1, 2):
    if not prime_num_booleans[num]:
        continue

    prime_factors.append(num)
        
    # Clear all future numbers from being Prime
    for j in range(num*2, PRIME_FACTOR_MAX+1, num):
        prime_num_booleans[j] = False

# Use prime factorization to work with up to MAX
# Count in Triangle Numbers looking at divisor counts
def calculateDivisors(number):
    if number in prime_factors: 
            return 1
    
    sum_prime_exponents = {}
    
    for prime in prime_factors:
        tmp_number = number

        if prime > tmp_number:
            break

        prime_exponent = 0
        # Check if prime is a factor by testing modulo
        while(tmp_number % prime == 0):
            tmp_number /= prime
            prime_exponent += 1

        sum_prime_exponents[prime] = prime_exponent + 1
        # print(f'Prime: {prime} Exponent: {sum_prime_exponents[prime]}')
    
    total_divisors = 1
    for key in sum_prime_exponents.keys():
        total_divisors *= sum_prime_exponents[key]

    return total_divisors


triangle_number = 0
i = 0
while(True):
    i += 1
    triangle_number += i
    if calculateDivisors(triangle_number) >= DESIRED_DIVISOR_COUNT:
        print(triangle_number)
        break
